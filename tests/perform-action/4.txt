;Given a situation where:
;
; - Calling turtle's breed is 'chrest-turtles'.
; - Every action in global 'possible actions' list is checked and can be performed successfully.
; - Calling turtle can reinforce problem-solving?.
; - Pattern-recognition used to create all action-patterns.
;
;This tests that the following conditions are true for each action performed: 
;
; - Boolean true is reported by the 'perform-action' procedure after every call.
; - If a 'move-randomly' action is performed then the turtle's 'episodic-memory' variable length should be 0 since 'move-randomly' action
;   patterns should never be added to a turtle's 'episodic-memory' because they should never have a chance of being associated with visual 
;   chunks (don't want to bias a turtle's random movement given stochasticity of Tileworld).
; - If any other action than 'move-randomly' is performed then the length of the calling turtle's episodic memory should increase by 1 
;   every time the 'perform-action' procedure is called. Also, after multiple perfomances of this action, only zero or one action-links 
;   between the visual chunk and the action itself should exist in the turtle's LTM for the visual chunk since every action pattern is  
;   created using pattern-recognition?.
; - Not interested as to the correctness of a turtle's 'episodic-memory' contents since this is checked in another test.

<test>
	foreach(possible-actions)[

		;Need to setup here since the CHREST turtle needs to be reset after every action checked otherwise checks of episodic memory length
		;and number of LTM visual-action links will become ambiguous.
		reset (true)
		create-chrest-turtles 1[
			set add-link-time (10000)
			set discrimination-time (10000)
			set episodic-memory ([])
			set familiarisation-time (2000)
			set max-length-of-episodic-memory (30000)
			set play-time (14400000.0)
			set problem-solving? (true)
			set reinforce-actions? (true)
			set reinforce-problem-solving? (true)
			set reinforcement-learning-theory ("profit_sharing_with_discount_rate")
			set sight-radius (2)
			setup-chrest-turtles(true)
		]

		;If the action is a 'push-tile' action, create a tile north of the calling turtle so that the action and visual patterns will 
		;be reinforced since the move will be successful.
		if(? = push-tile-token)[
			create-tiles 1 [ 
				setxy ( ([pxcor] of turtle 0) ) ( ([pycor] of turtle 0) + 1 )
				set heading 0
			]
		]

		;If the action token is not 'move-randomly' then, given the setup of the CHREST turtle, it will attempt to associate the 
		;action-pattern with a visual chunk generated by looking at the calling turtle's observable environment.  If there is nothing
		;but the calling turtle then the visual chunk will always be empty and this chunk will never be committed to LTM resulting
		;in an action link never being formed.  This causes the while loop in the 'ask turtle 0' code fragement below to run forever so,
		;at every possible patch, there should be some object so a non-empty visual chunk is created.  This is what the code below 
		;achieves.
		if(? != move-randomly-token)[
			let ycoord min-pycor
			while[ycoord <= max-pycor][
				create-tiles 1 [setxy (([pxcor] of turtle 0) + 1) (ycoord) ]
				set ycoord (ycoord + 1)
			]
		]

		ask turtle 0[
			let heading-value (0)
		
			ifelse(? = move-randomly-token)[
				check-test-output ( perform-action ( list (chrest:create-item-square-pattern (?) (heading-value) (1) ) (true) ) ) (true)
				check-equal (length episodic-memory) (0)
			]
			[
				let expected-length-episodic-memory 1
				let visual-chunk ""

				repeat 100 [
					set visual-chunk ( generate-chrest-compatible-visual-chunk(look-around) )
					let action-pattern ( chrest:create-item-square-pattern (?) (heading-value) (1) )
					
					check-equal ( perform-action ( list (action-pattern) (true) ) ) (true)
					check-equal (length episodic-memory) (expected-length-episodic-memory)
					check-test-output ( length (chrest:recognise-pattern-and-return-patterns-of-specified-modality ("visual") ("item_square") (visual-chunk) ("action")) ) (list (0) (1))

					set expected-length-episodic-memory (expected-length-episodic-memory + 1)
					set current-training-time (current-training-time + 10000)
				]
			]
		]
	]
</test>
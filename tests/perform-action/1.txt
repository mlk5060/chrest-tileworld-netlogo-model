;==============================
;========== TEST AIM ==========
;==============================
;
; To determine if the 'perform-action' procedure operates as expected when:
;
; 1) All valid actions are performed.
; 2) Each action is performed unsuccessfully.
; 3) The calling turtle is a CHREST turtle.
;
;======================================
;========== TEST DESCRIPTION ==========
;====================================== 
;
; 1) Each action declared in the global 'possible-actions' list is performed and the following procedure is applied.
; 2) A CHREST turtle is created with all essential turtle variables set.  Of note are the following:
;    - sight-radius: set to 1, important to understand the output of the "get-observable-environment" procedure that is invoked to generate the visual info that 
;                    should be passed to the "perform-action" procedure.
; 3) The CHREST turtle's observable environment is populated with resources to ensure that some visual information can be passed to the "perform-action" procedure.
;    The resources are also organised in such a way that the action performed will be unsuccessful.  If the action to perform is not a 'push-tile' action then the
;    CHREST turtle is surrounded by tiles (any other action than 'push-tile' just involves the CHREST turtle moving north by one patch).  If the action to perform 
;    is a 'push-tile' action then the patch ahead of the CHREST turtle has no tile placed on it.
; 4) The CHREST turtle gets the state of its observable environment and prepares the data for use by the "perform-action" procedure.
; 5) The CHREST turtle commits the state of its observable environment to LTM (it learns).  This is done now since a production can be added to this learned visual
;    state in LTM but only if the action is performed successfully.  Therefore, it is possible to assert that no production is added since action performance should
;    be unsuccessful.
; 6) The CHREST turtle performs the action specified.  For every action, the action heading and patches to move are set to 0 (north) and 1, respectively.  Each action 
;    is performed 50 times and the state of the environment is reset after each repetition (to ensure the subsequent action is performed unsuccessfully).  Some tests
;    are performed after each repeat.
; 7) Remaining tests are performed after the action performance loop has completed.
;
; Since the action is always performed unsuccessfully, the CHREST turtle should never create an action node in LTM and never add a production to the visual node 
; created after learning the visual information.
;
;=====================================
;========== TESTS PERFORMED ==========
;=====================================
;
; - After every invocation of "perform-action":
;   ~ A check is made to see if the action was performed successfully.  This check should always evaluate to 'false'.
;
; - Following the repeated invocations of "perform-action", the following values are checked:
;
;   ~ CHREST's learning clock.
;     + The action performed shouldn't be learned (see the "TEST DESCRIPTION" section above) so the clock should still be set to the time it was set to after 
;       learning of the visual information finishes.
;
;	~ The number of productions created for the visual node created in LTM after learning the observable environment state should be 0 (no actions learned so
;     no productions can/should be created).
;
;   ~ The number of productions that exist across visual LTM should be 0 (just to ensure no "rogue" productions have been created).
;
;   ~ The number of nodes in action LTM should be 1: the action LTM root node is always included in this count and no other actions should have been learned (no new
;     action nodes added).
;
;	~ The length of episodic memory should be 0 since the action is never performed successfully so is never learned so is never used in construction of a production
;     so storing information (episode) that facilitates reinforcement of a non-existing production is pointless.
;
<test>
	foreach(possible-actions)[

		let action (?)

		;=========================;
		;== SETUP CHREST TURTLE ==;
		;=========================;

		create-chrest-turtles 1[
			set action-performance-time (10000)
			set action-selection-procedure ("roulette-selection")
			set add-link-time (10000)
			set discount-rate (0.5)
			set discrimination-time (10000)
			set familiarisation-time (2000)
			set max-length-of-episodic-memory (30000)
			set max-search-iteration (5)
			set number-fixations (4)
			set pattern-recognition? (true)
			set play-time (14400000.0)
			set reinforce-actions? (true)
			set reinforce-problem-solving? (true)
			set reinforcement-learning-theory ("profit_sharing_with_discount_rate")
			set sight-radius (1)
			set time-taken-to-use-pattern-recognition (200)
			set time-taken-to-problem-solve (1000)
			set visual-spatial-field-access-time (50)
			set visual-spatial-field-empty-square-placement-time (5)
			set visual-spatial-field-object-movement-time (25)
			set visual-spatial-field-object-placement-time (10)
			set visual-spatial-field-recognised-object-lifespan (100000)
			set visual-spatial-field-unrecognised-object-lifespan (90000)
		]
		setup(true)

		;=====================================;
		;== GENERATE ENVIRONMENT FOR TURTLE ==;
		;=====================================;

		let ycord (-1)
		while[ycord <= 1][
			let xcord (-1)
			while[xcord <= 1][
				create-tiles 1 [setxy (([pxcor] of turtle 0) + xcord) (([pycor] of turtle 0) + ycord)]
				set xcord (xcord + 1)
			]
			set ycord (ycord + 1)
		]

		ask turtle 0 [

			if (action = push-tile-token)[
				ask tiles-on (patch-at-heading-and-distance (0) (1))[
					die
				]
			]

			;=============================================;
			;== GENERATE CURRENT OBSERVABLE ENVIRONMENT ==;
			;=============================================;

			;Information will be used by the "perform-action" procedure and to generate a visual
			;jchrest.lib.ListPattern to learn.

			let observable-environment ( get-observable-environment )
			foreach (observable-environment)[
		        let patch-info-with-object-id (?)
		        let patch-info-without-object-id (remove-item (2) (patch-info-with-object-id))
		        set observable-environment (replace-item 
					(position (patch-info-with-object-id) (observable-environment)) 
					(observable-environment) 
					(patch-info-without-object-id)
		        )
	      	]

	      	;==========================================================;
			;== LEARN LIST-PATTERN OF CURRENT OBSERVABLE ENVIRONMENT ==;
			;==========================================================;

			;To learn, CHREST requires a jchrest.lib.ListPattern so create a list of jchrest.lib.ItemSquarePatterns
			;from the observable environment information generated above.  This list can then be used by the 
			;"chrest:ListPattern.new" CHREST Netlogo extension primitive.

			let observable-environment-action-patterns []
			foreach (observable-environment)[
				let patch-content (?)
				set observable-environment-action-patterns (lput 
					(chrest:ItemSquarePattern.new 
						(item (2) (patch-content)) 
						(item (0) (patch-content)) 
						(item (1) (patch-content))
					) 
					(observable-environment-action-patterns)
				)
			]

			;Create the jchrest.lib.ListPattern instance to learn from the list of jchrest.lib.ItemSquarePatterns
			;created above and set its jchrest.lib.Modality to "visual".

			let observable-environment-list-pattern (chrest:DomainSpecifics.normalise-list-pattern 
				(chrest:ListPattern.new 
					("visual") 
					(observable-environment-action-patterns)
				)
			)

			;Learn the visual jchrest.lib.ListPattern created.

			let recognised-list-pattern (chrest:Node.get-image (chrest:recognise-and-learn-list-pattern (observable-environment-list-pattern) (report-current-time)))
			while [ chrest:ListPattern.get-as-string (recognised-list-pattern) != (chrest:ListPattern.get-as-string (observable-environment-list-pattern)) ][
				set recognised-list-pattern (chrest:Node.get-image 
					(chrest:recognise-and-learn-list-pattern 
						(observable-environment-list-pattern) 
						(report-current-time)
					)
				)
				set current-training-time (chrest:get-learning-clock)
			]

			;=======================;
	      	;== PERFORM TEST LOOP ==;
	      	;=======================;

			let perform-action-first-param (list (list (action) (0) (1)) (false) )
			let turtle-0-original-location (list xcor ycor)
			let repetitions (100)

			let expected-learning-clock (chrest:get-learning-clock)
			let expected-number-productions (0)
			let expected-productions []
			let expected-length-episodic-memory (0)
			let expected-number-productions-across-visual-ltm (0)
			let expected-size-action-ltm (1)
		
			repeat (repetitions)[

				;====================;
				;== PERFORM ACTION ==;
				;====================;

				let action-performed-successfully (perform-action (perform-action-first-param) (observable-environment))

				;======================================;
				;== CHECK FOR SUCCESSFUL PERFORMANCE ==;
				;======================================;

				check-equal 
					(action-performed-successfully) 
					(false) 
					(word "when checking if '" action "' action is performed successfully")

				;=================================;
				;== RESET LOCATION OF TURTLE 0  ==;
				;=================================;

				set xcor (item (0) (turtle-0-original-location))
				set ycor (item (1) (turtle-0-original-location))

				set current-training-time (chrest:get-learning-clock)
			]

			;===========================;
			;== POST TEST LOOP CHECKS ==;
			;===========================;

			let test-description (word "after exiting the performance loop for action " action)

			check-equal 
				(chrest:get-learning-clock)
				(expected-learning-clock)
				(word "when checking CHREST's learning clock " test-description)

			let productions ( map 
				([ chrest:ListPattern.get-as-string (chrest:Node.get-image (item (0) (?))) ]) 
				( chrest:recognise-list-pattern-and-return-nodes-with-modality 
					(observable-environment-list-pattern) 
					("action") 
					(report-current-time)
				)
			)

			check-equal
				(length productions)
				(expected-number-productions)
				(word "when checking the number of productions " test-description)

			check-equal
				(chrest:get-ltm-modality-num-action-links ("visual"))
				(expected-number-productions-across-visual-ltm)
				(word "when checking the number of productions that exist across visual LTM " test-description)

			check-equal
				(chrest:get-ltm-modality-size ("action"))
				(expected-size-action-ltm)
				(word "when checking the size of action LTM " test-description)

			check-equal 
				(length episodic-memory) 
				(expected-length-episodic-memory) 
				(word "when checking the length of episodic memory " test-description)
		]

		reset (true)
	]
</test>
;==============================
;========== TEST AIM ==========
;==============================
;
; To determine if the 'perform-action' procedure operates as expected for all possible actions in the model when:
;
; 1) The calling turtle's breed is 'chrest-turtles'.
; 2) Every action is performed successfully.
; 3) The calling turtle can reinforce problem-solving.
; 4) Problem-solving is used to generate the action performed.
;
;
;======================================
;========== TEST DESCRIPTION ==========
;====================================== 
;
; Every action created has:
; - Heading = 0 (due north)
; - Number of patches = 1
;
; Since problem-solving is used to generate the action and both problem-solving and explicit actions can be used as the "action" part of productions, the
; CHREST turtle should eventually create two productions from the same visual node where one terminates with the explicit action and the other terminates
; with the 'problem-solving' action.
;
;=====================================
;========== TESTS PERFORMED ==========
;=====================================
;
;This tests that the following conditions are true for each action performed: 
;
; - Boolean true is reported by the 'perform-action' procedure after every call.
; - If a 'move' action is performed then the turtle's 'episodic-memory' variable length should be 0 since 'move' action
;   patterns should never be added to a turtle's 'episodic-memory' because they should never have a chance of being associated with visual 
;   chunks (don't want to bias a turtle's free movement given stochasticity of Tileworld).
; - If any other action than 'move' is performed then the length of the calling turtle's episodic memory should increase by 1 
;   every time the 'perform-action' procedure is called. Also, two production between the visual chunk and the 'problem-solving?' action should 
;   be present in the calling turtle's visual LTM.  This is implicitly checked since the test will run forever if a production isn't created.
; - Not interested as to the correctness of a turtle's 'episodic-memory' contents since this is checked in another test.
;
<test>
	foreach(possible-actions)[
		
		let action (?)
		let action-pattern ( chrest:ItemSquarePattern.new (action) (0) (1) )
		let action-list-pattern (chrest:ListPattern.new ("action") (list (action-pattern)))

		;Need to setup here since the CHREST turtle needs to be reset after every action checked otherwise checks of episodic memory length
		;and number of LTM visual-action links will become ambiguous.
		reset (true)
		create-chrest-turtles 1[
			set add-link-time (10000)
			set discrimination-time (10000)
			set episodic-memory ([])
			set familiarisation-time (2000)
			set max-length-of-episodic-memory (30000)
			set visual-spatial-field-object-movement-time (25)
			set number-fixations (4)
			set play-time (14400000.0)
			set probability-of-creating-problem-solving-production (1.0)
			set probability-of-reinforcing-problem-solving (0.5)
			set reinforce-actions? (true)
			set reinforce-problem-solving? (true)
			set reinforcement-learning-theory ("profit_sharing_with_discount_rate")
			set sight-radius (1)
			setup-chrest-turtles (true)
		]


		;If the action is not a 'move' action then, given the setup of the CHREST turtle, it will attempt to associate the 
		;action with a visual chunk generated by looking at the calling turtle's observable environment.  If there is nothing
		;but the calling turtle then the visual chunk will always be empty and this chunk will never be committed to LTM resulting
		;in an action link never being formed.  This causes the while loop in the 'ask turtle 0' code fragment below to run forever so,
		;at every patch in the turtle's observable environment, there should be some object so a non-empty visual chunk is created.  This
		;is what the code below achieves.
		if(action != move-token)[
			let ycord (-1)
			while[ycord <= 1][
				let xcord (-1)
				while[xcord <= 1][

					ifelse( (xcord = 0 and ycord = 0) or (xcord = 0 and ycord = 1 and action != push-tile-token) )[]
					[
						create-tiles 1 [setxy (([pxcor] of turtle 0) + xcord) (([pycor] of turtle 0) + ycord)]
					]
					set xcord (xcord + 1)
				]
				set ycord (ycord + 1)
			]
		]

		ask turtle 0[
			let heading-value (0)
		
			ifelse(? = move-token)[
				check-equal 
					( perform-action (list (action-pattern) (false)) ) 
					(true) 
					("when checking output for move action")

				check-equal 
					(length episodic-memory) 
					(0) 
					("when checking length of episodic memory for move action")
			]
			[
				;=============================================================;
				;== GENERATE LIST-PATTERN OF CURRENT OBSERVABLE ENVIRONMENT ==;
				;=============================================================;

				let observable-environment ( get-observable-environment )
				let observable-environment-as-list-of-item-square-patterns []
				foreach (observable-environment)[
					let patch-seen (?)
					let xcor-patch-seen (item (0) (patch-seen))
					let ycor-patch-seen (item (1) (patch-seen))
					let object-patch-seen (item (3) (patch-seen))
					set observable-environment-as-list-of-item-square-patterns (lput chrest:ItemSquarePattern.new (xcor-patch-seen) (ycor-patch-seen) (object-patch-seen))
				]

				set observable-environment (chrest:ListPattern.new ("visual") (observable-environment-as-list-of-item-square-patterns))
				let observable-environment-string (chrest:ListPattern.get-as-string (observable-environment))

				;==========================================================;
				;== LEARN LIST-PATTERN OF CURRENT OBSERVABLE ENVIRONMENT ==;
				;==========================================================;
				
				while [ 
					(chrest:ListPattern.get-as-string 
						(chrest:Node.get-image 
							(chrest:recognise-and-learn-list-pattern (observable-environment) (report-current-time))
						)
					) != observable-environment-string
				][
					set current-training-time (chrest:get-learning-clock)
				]

				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;;;; 24TH OCTOBER - UP TO HERE ;;;;;
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

				let number-of-productions (length 
					(chrest:recognise-list-pattern-and-return-nodes-with-modality 
						(observable-environment) 
						("action") 
						(report-current-time)
					)
				)

				let original-location (list xcor ycor)
				let expected-length-episodic-memory 1

				;Until this visual-chunk has got one production, keep performing the action.
				while[ number-of-productions < 2 ][

					set xcor (item (0) (original-location))
					set ycor (item (1) (original-location))
					
					set observable-environment ( scan-scene-using-chrest (chrest:Scene.new ( get-observable-environment ) ("")) )

					output-print (chrest:ListPattern.get-as-string (observable-environment))

					check-equal 
						( perform-action (list (action-pattern) (false)) ) 
						(true) 
						("when checking output for non-move action")

					check-equal 
						(length episodic-memory) 
						(expected-length-episodic-memory) 
						("when checking length of episodic memory for non-move action")

					set expected-length-episodic-memory (expected-length-episodic-memory + 1) 
					set current-training-time (chrest:get-learning-clock)
					set number-of-productions length (chrest:recognise-list-pattern-and-return-nodes-with-modality (observable-environment) ("action") (report-current-time))
				]
			]
		]

		ask tiles[
			die
		]
	]
</test>
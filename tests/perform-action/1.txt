;==============================
;========== TEST AIM ==========
;==============================
;
; To determine if the "perform-action" procedure behaves as expected for CHREST turtles when every possible combination of parameters that controls access through 
; the CHREST turtle section of the procedure is tested.
;
;======================================
;========== TEST DESCRIPTION ==========
;====================================== 
; 
; There are 7 parameters that control access through the CHREST turtle section of the "generate-plan" procedure and each parameter can be set to a varying number of 
; values. These parameters can be combined in up to 128 different ways (4 * 2 * 2 * 2 * 2 * 2 * 4) resulting in 512 different scenarios that can be tested.  The 
; parameters are listed below with their possible values nested beneath:
; 
; - Action performed
;   ~ Move action
;   ~ Move around tile action
;   ~ Move to tile action
;   ~ Push tile action
;
; - Whether action-performance time has elapsed
;   ~ True
;   ~ False
;
; - Is there a hole avaialble to push a tile into?
;   ~ True
;   ~ False
;
; - How action is generated
;   ~ Problem-solving
;   ~ Pattern-recognition
;
; - Outcome of performing action
;   ~ Success
;   ~ Failure
;
; - Visual information passed to the "perform-action" function
;   ~ Evaluated as empty by the "perform-action" function
;   ~ Evaluated as not empty by the "perform-action" function
;
; - Whether the CHREST turtle can reinforce problem-solving and/or explicit action productions
;   ~ Can reinforce problem-solving and explicit action productions
;   ~ Can reinforce problem-solving but not explicit action productions
;   ~ Can't reinforce problem-solving but can reinforce explicit action productions
;   ~ Can't reinforce problem-solving or explicit action productions
;
; The test is comprised of the 128 scenarios described above and will only end when all combinations of each parameter value have been set and the "perform-action"
; procedure called with the parameter values set. The "perform-action" procedure is repeatedly invoked for a set number of times to ensure that, if the scenario 
; parameters are set so that episode/production creation should occur, all expected productions should be created. 
;
; Parameter setting is performed by randomly combining the potential values for each parameter (avoids human error and programming effort by manually setting each
; parameter value for each scenario).  If the combination of parameter values has already been tested, a new combination is generated.  This will continue until 
; the parameter values set have not occurred before in the test.
;
; NOTE: The action performed will always have a heading of 0 (due north) and number of patches = 1.
; 
;=====================================
;========== TESTS PERFORMED ==========
;=====================================
;
; The following values are checked after each invocation of "perform-action" during the "perform-action" invocation loop:
; - Action performed successfully?
; - If the scenario entails that episodes should be created, the episode just added to episodic memory will be checked for correctness.
;
; The following values are checked after the "perform-action" invocation loop has completed:
;
; - Number of productions created for visual information supplied to "perform-action".
; - Number of productions across visual LTM.
; - The action node that each production (if any are created in the scenario) terminates with.
; - The length of episodic memory.
; 
<test>
	let scenarios-tested []
	let number-perform-action-repetitions (200)

	while[length scenarios-tested < 512][

		;====================;
		;== SETUP SCENARIO ==;
		;====================;

		let action 										(one-of (possible-actions))
		let action-performance-time-elapsed             (one-of (list (true) (false)))
		let hole-available                              (one-of (list (true) (false)))
		let action-generated-using-pattern-recognition? (one-of (list (true) (false)))
		let action-performed-successfully? 				(one-of (list (true) (false)))
		let vision-empty? 								(one-of (list (true) (false)))
		let reinforce-prob-sol? 						(one-of (list (true) (false)))
		let reinforce-act? 								(one-of (list (true) (false)))

		let scenario (word 
			action " "
			action-performance-time-elapsed " " 
			hole-available " "
			action-generated-using-pattern-recognition? " " 
			action-performed-successfully? " " 
			vision-empty? " " 
			reinforce-prob-sol? " " 
			reinforce-act?
		)

		while[member? scenario scenarios-tested][
			set action 										(one-of (possible-actions))
			set action-performance-time-elapsed             (one-of (list (true) (false)))
			set hole-available                              (one-of (list (true) (false)))
			set action-generated-using-pattern-recognition? (one-of (list (true) (false)))
			set action-performed-successfully? 				(one-of (list (true) (false)))
			set vision-empty? 								(one-of (list (true) (false)))
			set reinforce-prob-sol? 						(one-of (list (true) (false)))
			set reinforce-act? 								(one-of (list (true) (false)))

			set scenario (word 
				action " "
				action-performance-time-elapsed " " 
				hole-available " "
				action-generated-using-pattern-recognition? " " 
				action-performed-successfully? " " 
				vision-empty? " " 
				reinforce-prob-sol? " " 
				reinforce-act?
			)
		]

		set scenarios-tested (lput 
			(scenario)
			(scenarios-tested)
		)

		;======================================================================;
		;== CHECK IF THE SCENARIO WILL ALLOW FOR EPISODE/PRODUCTION CREATION ==;
		;======================================================================; 

		let scenario-will-create-episode-and-production (false)

		; This is essentially a duplication of the conditional that controls access to episode/production 
		; creation for CHREST turtles in the "perform-action" procedure with the addition of the 
		; 'action-performance-time-elapsed' parameter check.
		if(
			(action-performance-time-elapsed) and
			(action != move-token) and
			(action-performed-successfully?) and
			(not vision-empty?) and
			(reinforce-prob-sol? or reinforce-act?) and
			(not 
				(
					(action-generated-using-pattern-recognition?) and 
					(not reinforce-act?)
				)
			)
		)[
			set scenario-will-create-episode-and-production (true)
		]

		;=========================;
		;== SETUP CHREST TURTLE ==;
		;=========================;

		create-chrest-turtles 1[
			set action-performance-time (10000)
			set action-selection-procedure ("roulette-selection")
			set add-link-time (10000)
			set can-plan? (true)
			set discount-rate (0.5)
			set discrimination-time (10000)
			set familiarisation-time (2000)
			set max-length-of-episodic-memory (30000)
			set max-search-iteration (5)
			set number-fixations (4)
			set pattern-recognition? (true)
			set play-time (14400000.0)
			set reinforcement-learning-theory ("profit_sharing_with_discount_rate")
			set sight-radius (2)
			set time-taken-to-use-pattern-recognition (200)
			set time-taken-to-problem-solve (1000)
			set visual-spatial-field-access-time (50)
			set visual-spatial-field-empty-square-placement-time (5)
			set visual-spatial-field-object-movement-time (25)
			set visual-spatial-field-object-placement-time (10)
			set visual-spatial-field-recognised-object-lifespan (100000)
			set visual-spatial-field-unrecognised-object-lifespan (90000)

			; NOTE: these variables are set to whatever the relevant scenario parameters are set to.
			set reinforce-actions? (reinforce-act?)
			set reinforce-problem-solving? (reinforce-prob-sol?)
		]
		setup(true)

		;=========================;
		;== SET EXPECTED VALUES ==;
		;=========================;

		; Initialise expected values to the most basic scenario set-up, i.e. the action was not performed since the time specified for 
		; action performance has not elapsed.  In this case, nothing should occur and the action-performance result should be an empty
		; list.

		let expected-success-of-action-performance []
		let expected-number-productions (0)
		let expected-num-productions-across-visual-ltm (0)
		let expected-productions []
		let expected-length-episodic-memory (0)
		let expected-action-ltm-size (1)
		
		;============================;
		;== MODIFY EXPECTED VALUES ==;
		;============================;

		; If the time specified for action performance has elapsed then set paramaters accordingly.
		if(action-performance-time-elapsed)[
			
			; The next most complex scenario if the time specified for action performance has elapsed is:
			; 
			; 1. The action was generated by pattern-recognition.
			; 2. The action is not a "push-tile" action.
			; 2. No episode/production creation should occur.
			; 
			; In this case the CHREST turtle should just learn the explicit action performed and return the expected
			; action performance variable.
			;
			; NOTE: even though only the explicit action should be learned, the action LTM root node is included
		    ;       in CHREST's node count for any LTM modality.  So, the expected size of LTM is always equal to 
		    ;       1 + the number of nodes that should be added.
		    
		    set expected-action-ltm-size (2)
			set expected-success-of-action-performance (action-performed-successfully?)

			; If the action is to push a tile then the "perform-action" procedure will report a list since that is what 
			; is reported by the "push-tile" procedure when invoked.  The list will contain two elements, the first states 
			; whether the action was performed successfully or not and its expected value is dependent on the value of the 
			; 'action-performed-successfully?' scenario parameter.  The second element stipulates whether a hole was filled 
			; when a tile was pushed.  This value is dependent first on the value of the "action-performed-successfully?"
			; scenario paramater then the value of the "hole-available" scenario parameter.  If the 
			; "action-performed-successfully?" parameter is set to 'true' then the tile may be pushed and may/may not be
			; pushed into a hole.  If the "action-performed-successfully?" parameter is set to 'false' then a hole will
			; never be filled.
			if (action = push-tile-token)[
				ifelse (action-performed-successfully?)[
					set expected-success-of-action-performance (list (true) (hole-available))
				]
				[
					set expected-success-of-action-performance (list (false) (false))
				]
			]

			; If problem-solving was used to generate the action to perform, the CHREST turtle should learn the 
			; 'problem-solving' action as well as the explicit action so the number of nodes in LTM should be 
			; incremented by 1.
			if(not action-generated-using-pattern-recognition?)[
				set expected-action-ltm-size (expected-action-ltm-size + 1)
			]

			; If the scenario parameters are set in a way that will cause an episode and production to be created, 
			; update other expected values.
			if(scenario-will-create-episode-and-production)[

				; In most cases only one production will be created (either a 'problem-solving' production or an 
				; explicit action production).  
				set expected-number-productions (1)
				set expected-num-productions-across-visual-ltm (1)

				; If episode creation will occur, an episode will be added after each invocation of "perform-action".  
				; Since episodic memory is much larger than the number of "peform-action" repetitions that will occur, 
				; the final length of episodic memory will be equal to the number of times "perform-action" is invoked, 
				; i.e. the number of repetitions set. 
				set expected-length-episodic-memory (number-perform-action-repetitions)

				; In most cases, the explicit action will be the production created.
				set expected-productions (lput 
					(chrest:ListPattern.get-as-string ( chrest:ListPattern.new ("action") (list ( chrest:ItemSquarePattern.new (action) (0) (1) )) ))
					(expected-productions)
				)
				
				; If the action was generated using problem-solving, things get tricky.
				if(not action-generated-using-pattern-recognition?)[

					; If its the case that the turtle can reinforce both 'problem-solving' productions and explicit action 
					; production then these productions are expected to be created.
					if(reinforce-prob-sol? and reinforce-act?)[
						set expected-number-productions (2)
						set expected-num-productions-across-visual-ltm (2)
						set expected-productions (lput 
							(chrest:ListPattern.get-as-string ( chrest:ListPattern.new ("action") (list ( chrest:ItemSquarePattern.new (problem-solving-token) (0) (0) )) ))
							(expected-productions)
						)
					]

					; If its the case that the turtle can only reinforce problem-solving, only the problem-solving 
					; production should be created.
					if(reinforce-prob-sol? and not reinforce-act?)[
						set expected-productions (list 
							(chrest:ListPattern.get-as-string ( chrest:ListPattern.new ("action") (list ( chrest:ItemSquarePattern.new (problem-solving-token) (0) (0) )) ))
						)
					]
				]
			]
		]

		;===================================================;
		;== MODIFY CHREST TURTLE'S OBSERVABLE ENVIRONMENT ==;
		;===================================================;

		; If the action should be performed successfully then, since most actions are simple movements of the CHREST turtle 1 patch north, 
		; the patch ahead of the CHREST turtle should not contain any other turtles (holes/tiles/opponents) so don't add any turtles.
		; If the action is to push a tile then things are a little more complex:
		;
		; - If the scenario stipulates that the action should be performed successfully then add a tile.
		; - If the scenario also stipulates that a hole should be available, create a hole in front of the tile otherwise, the action won't
		;   actually be performed successfully.
		if(
			action = push-tile-token and 
			action-performed-successfully?
		)[
			create-tiles 1 [setxy ([pxcor] of turtle 0) (([pycor] of turtle 0) + 1)]

			if(hole-available)[
				create-holes 1 [setxy ([pxcor] of turtle 0) (([pycor] of turtle 0) + 2)]
			]
		]

		if(
			action != push-tile-token and not action-performed-successfully?
		)[
			create-tiles 1 [setxy ([pxcor] of turtle 0) (([pycor] of turtle 0) + 1)]
		]

		; If the scenario stipulates that the visual information passed to the "perform-action" procedure shouldn't be evaluated as empty then
		; create some other turtles to the east, south and west of the CHREST turtle (leave the patch north of the turtle as it is, see above).
		if (not vision-empty?)[
			create-chrest-turtles 1 [setxy ([pxcor] of turtle 0) (([pycor] of turtle 0) - 1)]
			create-chrest-turtles 1 [setxy (([pxcor] of turtle 0) + 1) ([pycor] of turtle 0)]
			create-chrest-turtles 1 [setxy (([pxcor] of turtle 0) - 1) ([pycor] of turtle 0)]
		]

		;=============================================================;
		;== GENERATE LIST-PATTERN OF CURRENT OBSERVABLE ENVIRONMENT ==;
		;=============================================================;

		let observable-environment []

		; The jchrest.lib.ListPattern representation of the CHREST turtle's current observable environment is used in a number of ways:
		; 1) To generate a visual node in the CHREST turtle's LTM through learning.  This acts as the visual part of any production
		;    that may be created (if the scenario parameters stipulate that this should occur).
		; 2) Used to check the contents of an episode added to episodic memory after each invocation of "perform-action" (if the scenario 
		;    parameters stipulate that this should occur).
		; 3) Used to retrieve any productions that may be created (if the scenario parameters stipulate that this should occur) so that
		;    their contents can be checked.
		let observable-environment-list-pattern []

		; Create a list to store jchrest.lib.ItemSquarePatterns that represent objects in the CHREST turtle's current 
		; observable environment.  If the scenario parameters stipulate that the visual information passed to the
		; "perform-action" procedure should be empty, then this list will remain empty.
		let observable-environment-action-patterns []

		ask turtle 0[

			; If the scenario parameters stipulate that the visual information passed to the "perform-action" procedure shouldn't 
			; be empty, then the CHREST turtle should get its observable environment and add object information as 
			; jchrest.lib.ItemSquarePatterns to the 'observable-environment-action-patterns' list in the format expected by the
			; "perform-action" procedure (see second parameter details in procedure).
			if(not vision-empty?)[

				set observable-environment ( get-observable-environment )
				foreach (observable-environment)[
			        let patch-info-with-object-id (?)
			        let patch-info-without-object-id (remove-item (2) (patch-info-with-object-id))
			        set observable-environment (replace-item 
						(position (patch-info-with-object-id) (observable-environment)) 
						(observable-environment) 
						(patch-info-without-object-id)
			        )
		      	]

				foreach (observable-environment)[
					let patch-content (?)
					set observable-environment-action-patterns (lput 
						(chrest:ItemSquarePattern.new 
							(item (2) (patch-content)) 
							(item (0) (patch-content)) 
							(item (1) (patch-content))
						) 
						(observable-environment-action-patterns)
					)
				]
			]

			; Instantiate the 'observable-environment-list-pattern' variable with the contents of 'observable-environment-action-patterns'.
			; NOTE: if 'observable-environment-action-patterns' is empty, the 'observable-environment-list-pattern' variable will also
			;       be empty (has implications below).
			set observable-environment-list-pattern (chrest:DomainSpecifics.normalise-list-pattern 
				(chrest:ListPattern.new 
					("visual") 
					(observable-environment-action-patterns)
				)
			)
		]

		;=====================================================================;
		;== ATTEMPT TO LEARN LIST-PATTERN OF CURRENT OBSERVABLE ENVIRONMENT ==;
		;=====================================================================;

		; If the 'observable-environment-list-pattern' variable isn't empty, have the CHREST turtle learn its contents to ensure that
		; a visual node is generated (this will be used as the "start-point" of a production in the "perform-action" procedure if 
		; the scenario parameters stipulate that productions are expected to be created).  Following each  request for CHREST to learn 
		; the contents of 'observable-environment-list-pattern' variable, set the model time to the value f CHREST's learning clock so 
		; that, if the next request to learn will result in discrimination/familiarisation, it will be allowed to occur.
		if(not chrest:ListPattern.empty? (observable-environment-list-pattern))[

			ask turtle 0 [
			
				let recognised-chunk (chrest:ListPattern.get-as-string 
					(chrest:Node.get-image 
						(chrest:recognise-and-learn-list-pattern 
							(observable-environment-list-pattern) 
							(report-current-time)
						)
					)
				)

				while [recognised-chunk != (chrest:ListPattern.get-as-string (observable-environment-list-pattern))][
					
					set recognised-chunk (chrest:ListPattern.get-as-string 
						(chrest:Node.get-image
							(chrest:recognise-and-learn-list-pattern 
								(observable-environment-list-pattern) 
								(report-current-time)
							)
						)
					)

					set current-training-time (chrest:get-learning-clock)
				]
			]
		]

		;===================;
		;== PERFORM TEST  ==;
		;===================;

		ask turtle 0 [

			; Get the current location of the CHREST turtle and store it so that its position can be reset after every "perform-action"
			; procedure invocation.  This ensures that the CHREST turtle will/will not perform the action successfully (depending upon
			; relevant scenario parameters).
			let turtle-0-original-location (list xcor ycor)

			let scenario-description (word "during the following scenario:\n"
			    "1. Action performed = " action "\n"
			    "2. Action performance time elapsed = " action-performance-time-elapsed "\n"
			    "3. Hole available = " hole-available "\n"
			    "4. Action performed successfully = " action-performed-successfully? "\n"
			    "5. Visual list pattern empty = " vision-empty? " (" chrest:ListPattern.get-as-string (observable-environment-list-pattern) ")\n"
			    "6. Reinforce problem solving = " reinforce-prob-sol? "\n"
			    "7. Reinforce explicit actions = " reinforce-act? "\n"
			    "8. Pattern-recognition used to generate action = " action-generated-using-pattern-recognition?
		    )

		    ;======================================;
		    ;== "PERFORM-ACTION" INVOCATION LOOP ==;
		    ;======================================;

			repeat (number-perform-action-repetitions)[

				let action-performance-success (perform-action 
					(list
						(list
							(action)
							(0)
							(1)
						)
						(action-generated-using-pattern-recognition?) 
					) 
					(observable-environment)
				)

				if(action-performance-time-elapsed)[
					set current-training-time (current-training-time + action-performance-time)
					set action-performance-success (perform-action 
						(list
							(list
								(action)
								(0)
								(1)
							)
							(action-generated-using-pattern-recognition?) 
						) 
						(observable-environment)
					)
				]

				;================================================;
				;== CHECK FOR UN/SUCCESSFUL ACTION PERFORMANCE ==;
				;================================================;

				check-equal 
					(action-performance-success) 
					(expected-success-of-action-performance) 
					(word "when checking if the action is performed successfully " scenario-description)

				;=========================;
				;== CHECK EPISODE ADDED ==;
				;=========================;

				if(scenario-will-create-episode-and-production)[
				
					; Format the jchrest.lib.ListPatterns as string so that they can be compared.
					let last-episode-in-episodic-memory (last (episodic-memory))
					set last-episode-in-episodic-memory (replace-item 
						(0)
						(last-episode-in-episodic-memory)
						(chrest:ListPattern.get-as-string (item (0) (last-episode-in-episodic-memory)))
					)
					set last-episode-in-episodic-memory (replace-item 
						(1)
						(last-episode-in-episodic-memory)
						(chrest:ListPattern.get-as-string (item (1) (last-episode-in-episodic-memory)))
					)

					; Create the expected last episode.
					let expected-last-episode-in-episodic-memory (list
						(chrest:ListPattern.get-as-string (observable-environment-list-pattern))
						(chrest:ListPattern.get-as-string (chrest:ListPattern.new ("action") (list chrest:ItemSquarePattern.new (action) (0) (1))))
						(report-current-time)
						(action-generated-using-pattern-recognition?)
					)

					; Perform check.
					check-equal
						(last-episode-in-episodic-memory)
						(expected-last-episode-in-episodic-memory)
						(word "when checking the last episode in episodic memory " scenario-description)
				]

				;===========================;
				;== RESET TURTLE LOCATION ==;
				;===========================;

				setxy (item (0) (turtle-0-original-location)) (item (1) (turtle-0-original-location))
				ask tiles [die]
				ask holes [die]

				if(
					action = push-tile-token and 
					action-performed-successfully?
				)[
					ask patch-at-heading-and-distance (0) (1) [sprout-tiles 1]

					if(hole-available)[
						ask patch-at-heading-and-distance (0) (2) [sprout-holes 1]
					]
				]

				if(
					action != push-tile-token and not action-performed-successfully?
				)[
					ask patch-at-heading-and-distance (0) (1) [sprout-tiles 1]
				]

				; Set the model time to the current value of the CHREST turtle's learning clock since an action may have been learned or a 
				; production created in the last "generate-plan" invocation.  Thus, if any learning should occur again on the next "perform-action"
				; invocation, CHREST will not be blocked from doing so due to timing checks.
				set current-training-time (chrest:get-learning-clock)
			]

		    ;===========================;
			;== POST TEST LOOP CHECKS ==;
			;===========================;

			; Get any productions that were created given the scenario parameters and observable environment information passed to the
			; "perform-action" function.
			let productions ( map 
				([ chrest:ListPattern.get-as-string (chrest:Node.get-image (item (0) (?))) ]) 
				( chrest:get-productions
					(observable-environment-list-pattern)
					(report-current-time)
				)
			)

			check-equal
				(length productions)
				(expected-number-productions)
				(word "when checking the number of productions " scenario-description)

			foreach(expected-productions)[
				check-equal 
					(member? (?) (productions)) 
					(true) 
					(word "when checking if production '" ? "' is a member of the productions: " productions " created " scenario-description)
			]

			check-equal
				(chrest:get-ltm-modality-num-action-links ("visual"))
				(expected-num-productions-across-visual-ltm)
				(word "when checking the number of productions that exist across visual LTM " scenario-description)

			check-equal
				(chrest:get-ltm-modality-size ("action"))
				(expected-action-ltm-size)
				(word "when checking the size of action LTM " scenario-description)

			check-equal 
				(length episodic-memory) 
				(expected-length-episodic-memory) 
				(word "when checking the length of episodic memory " scenario-description)
		]
		
		reset (true)
	]
</test>
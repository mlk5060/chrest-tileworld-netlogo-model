;==============================
;========== TEST AIM ==========
;==============================
;
; 1) To determine if deliberation produces an expected action when the calling turtle is a CHREST turtle, can use pattern recognition and the environment 
;    matches the visual part of a learned production.
;
;======================================
;========== TEST DESCRIPTION ==========
;======================================
;
; 1) A CHREST turtle creates a production from its current environment and a defined action (entails the CHREST turtle committing the current 
;    environment state and defined action to its long-term memory).
; 2) The production is reinforced so that it is viable for selection using the "roulette-selection" algorithm.
; 3) Since the "deliberate" procedure makes use of CHREST's perceptual mechanisms to scan a Scene to decide upon what action to perform, it is not
; 	 guaranteed to generate a ListPattern representing what it can see that will cause the relevant production and defined action to be retrieved.
; 	 Therefore, the "deliberate" procedure is called until pattern-recognition is used to select an action (the defined action will be selected 
;    since the CHREST turtle hasn't committed any other productions to long-term memory).
; 4) The test itself is repeated 50 times to ensure that all "deliberation" output is handled correctly.
;
; The obserssvable environment state of the CHREST turtle is depicted visually below.  Each object is denoted by its "who" number followed by the 
; class of the object in parenthesis.
;
; LEGEND
; ======
;
; - H: hole
; - O: opponent
; - T: tile
; - S: self
;        
; |------|------|------|
; |      | 1(T) |      |
; |------|------|------|
; |      | 0(S) |      |
; |------|------|------|
; |      |      |      |
; |------|------|------|
;                                        
;=====================================
;========== TESTS PERFORMED ==========
;=====================================
;
; When the "deliberate" procedure uses pattern-recognition to generate an action, the variables reported are checked to see if they are as expected:
; 
; - The first item should be the defined action.
; - The second item should be the time taken to deliberate, i.e. the time defined for the CHREST turtle to use pattern-recognition.
; - The third item should be equal to true, i.e. the turtle used pattern-recognition to generate the action reported.
;
<test>
	repeat 50 [
		
		create-chrest-turtles 1[
			set action-performance-time 10000
			set action-selection-procedure "roulette-selection"
			set add-link-time 10000
			set can-plan? (true)
			set discount-rate 0.5
			set discrimination-time 10000
			set familiarisation-time 2000
			set max-length-of-episodic-memory (5)
			set max-search-iteration 5
			set number-fixations 15
			set pattern-recognition? true
			set play-time 14400000.0
			set reinforce-actions? true
			set reinforce-problem-solving? true
			set reinforcement-learning-theory "profit_sharing_with_discount_rate" 
			set sight-radius 1
			set time-taken-to-use-pattern-recognition 200
			set time-taken-to-problem-solve 1000
			set visual-spatial-field-access-time 50
			set visual-spatial-field-empty-square-placement-time 5
			set visual-spatial-field-object-movement-time 25
			set visual-spatial-field-object-placement-time 10
			set visual-spatial-field-recognised-object-lifespan 100000
			set visual-spatial-field-unrecognised-object-lifespan 90000
		]
		setup (true)

		create-tiles 1 [setxy ([pxcor] of turtle 0) (([pycor] of turtle 0) + 1)]

		ask turtle 0 [

			;==================================================;
			;== CREATE VISUAL AND ACTION DATA TO USE IN TEST ==;
			;==================================================;

			let observable-environment (get-observable-environment)
			let observable-environment-as-scene (chrest:Scene.new (observable-environment) ("test"))

			;When the ListPattern representing the observable environment as a Scene is learned, CHREST will normalise the ListPattern according to 
			;the DomainSpecifics class set as its current domain.  So, to control learning, it is necessary to check if what is recognised is equal
			;to what should be learned.  So, to do this correctly, the ListPattern should be normalised here.  Also, the "Scene.get-as-list-pattern"
			;extension primitive will cause the coordinates for objects in the ListPattern returned to be scene-specific rather than creator-specific.
			;This has implications later when the scene is scanned as part of the "deliberate" procedure since, when scanning, CHREST will attempt to
			;recognise what is scanned as ListPatterns containing ItemSquarePatterns whose coordinates are domain-specific, in this case, creator-relative.
			;Thus, if the scene-specific coordinates are not converted here, learned information will have scene-specific coordinates and when the model
			;attempts to recognise info in the scene, the creator-relative coordinates will never match up correctly causing an infinite loop (see the 
			;while loop that controls when deliberation ends).

			let visual-list-pattern ( chrest:DomainSpecifics.normalise-list-pattern 
				( chrest:DomainSpecifics.convert-scene-specific-coordinates-to-domain-specific-coordinates
					( chrest:Scene.get-as-list-pattern 
						(observable-environment-as-scene) (true) 
					)
					(observable-environment-as-scene)
				)
			)
			let action-pattern (chrest:ItemSquarePattern.new (push-tile-token) (180) (1))
			let action-list-pattern ( chrest:ListPattern.new ("action") (list action-pattern) )

			;=====================================;
			;== LEARN CURRENT ENVIRONMENT STATE ==;
			;=====================================;

			let result-of-chrest-recognising-visual-list-pattern ( 
				chrest:ListPattern.get-as-string (
					chrest:Node.get-image (
						chrest:recognise-and-learn (visual-list-pattern) (report-current-time)
					)
				)
			)

			while[ result-of-chrest-recognising-visual-list-pattern != (chrest:ListPattern.get-as-string (visual-list-pattern) ) ][
				set result-of-chrest-recognising-visual-list-pattern ( 
					chrest:ListPattern.get-as-string (
						chrest:Node.get-image (
							chrest:recognise-and-learn (visual-list-pattern) (report-current-time)
						)
					)
				)
				set current-training-time (chrest:get-learning-clock)
			]

			;==========================;
			;== LEARN DEFINED ACTION ==;
			;==========================;

			let result-of-chrest-recognising-action-list-pattern ( 
				chrest:ListPattern.get-as-string (
					chrest:Node.get-image (
						chrest:recognise-and-learn (action-list-pattern) (report-current-time)
					)
				)
			)

			while[ result-of-chrest-recognising-action-list-pattern != ( chrest:ListPattern.get-as-string (action-list-pattern) ) ][
				set result-of-chrest-recognising-action-list-pattern ( 
					chrest:ListPattern.get-as-string (
						chrest:Node.get-image (
							chrest:recognise-and-learn (action-list-pattern) (report-current-time)
						)
					)
				)
				set current-training-time (chrest:get-learning-clock)
			]

			;============================================================================;
			;== CREATE PRODUCTION BETWEEN CURRENT ENVIRONMENT STATE AND DEFINED ACTION ==;
			;============================================================================;

			while[ chrest:get-production-count = 0 ][
				chrest:associate-list-patterns (chrest:DomainSpecifics.normalise-list-pattern (visual-list-pattern)) (action-list-pattern) (report-current-time)
				set current-training-time (chrest:get-learning-clock)
			]

			;==========================;
			;== REINFORCE PRODUCTION ==;
			;==========================;

			;Note that the values int the list passed ensures that the production rating is > 0 so that the action will be selected using "roulette-selection"
			;during the "deliberate" procedure execution (if a rating is not > 0 it will not be selected).
			chrest:reinforce-production 
				(visual-list-pattern) 
				(action-list-pattern) 
				(list (1) (0.9) (report-current-time) (report-current-time - 1))
				(report-current-time)

			;===============================================;
			;== DELIBERATE UNTIL PATTERN-RECOGNITION USED ==;
			;===============================================;

			let deliberation-result (deliberate (observable-environment))
			while [not item (2) (deliberation-result)][
				set deliberation-result (deliberate (observable-environment))
			]
			
			;===========;
			;== TESTS ==;
			;===========;

			check-equal 
				(item (0) (deliberation-result)) 
				(list (push-tile-token) (180) (1)) 
				("when checking action returned")

			check-equal 
				(item (1) (deliberation-result))
				(time-taken-to-use-pattern-recognition)
				("when checking time taken to deliberate")

			check-equal 
				(item (2) (deliberation-result))
				(true)
				("when checking if pattern-recognition was used to deliberate")
		]
		reset (true)
	]
</test>